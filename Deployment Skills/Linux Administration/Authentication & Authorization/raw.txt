CompTIA Linux+: Authentication & Authorization
Linux authentication and authorization determine which entities have what access to specific resources. Managing user authentication methods including elevated privileges and remote management are critical skills for Linux technicians. In this course, I will begin with a discussion of authentication and authorization including how pluggable authentication module (PAM) works in Linux. I will then create and manage Linux user account and password settings. Next, I will create and manage Linux groups, configuration files, and I will configure sudo for normal user elevated privileges. Lastly, I will discuss various Linux remote management solutions, I will configure Secure Shell (SSH), and I will configure a Lightweight Directory Access Protocol (LDAP) server and client. This course can be used to prepare for the Linux+ XK0-005 certification exam.

Table of Contents
    1. Video: Course Overview (it_oslsec_02_enus_01)

    2. Video: Authentication and Authorization (it_oslsec_02_enus_02)

    3. Video: Pluggable Authentication Modules (PAM) (it_oslsec_02_enus_03)

    4. Video: Managing Linux User Accounts and Password Settings (it_oslsec_02_enus_04)

    5. Video: Creating and Managing Linux Groups (it_oslsec_02_enus_05)

    6. Video: Viewing and Managing Linux User Configuration Files (it_oslsec_02_enus_06)

    7. Video: Using sudo to Gain Elevated Privileges (it_oslsec_02_enus_07)

    8. Video: Linux Remote Management (it_oslsec_02_enus_08)

    9. Video: Secure Shell (SSH) Port Forwarding and Tunneling (it_oslsec_02_enus_09)

    10. Video: Configuring SSH Remote Management (it_oslsec_02_enus_10)

    11. Video: Installing and Configuring an LDAP Server (it_oslsec_02_enus_11)

    12. Video: Configuring LDAP Client Authentication (it_oslsec_02_enus_12)

    13. Video: Course Summary (it_oslsec_02_enus_13)

1. Video: Course Overview (it_oslsec_02_enus_01)

In this video, we will discover the key concepts covered in this course.
discover the key concepts covered in this course
[Video description begins] Topic Title: Course Overview. Your host for this session is Dan Lachance. [Video description ends] [Video description begins] A slide titled learning objectives appears. [Video description ends]
Linux authentication and authorization, both determine which entities have which access to specific resources. And so managing user authentication methods, including elevated privileges and remote management, are critical skills for Linux technicians.

In this course, I'll begin with a discussion of authentication and authorization, including how PAM works in Linux. I will then create and manage Linux user accounts and work with password settings. Next, I will create and manage Linux groups. I'll work with configuration files and configure sudo for normal user elevated privileges.

Lastly, I will discuss various Linux remote management solutions, I will configure SSH and I will configure an LDAP server and client. This course can be used to prepare for the Linux+ XK0-005 certification exam.

2. Video: Authentication and Authorization (it_oslsec_02_enus_02)

After completing this video, you will be able to outline the role authentication plays including the use of Lightweight Directory Access Protocol (LDAP).
outline the role authentication plays including the use of Lightweight Directory Access Protocol (LDAP)
[Video description begins] Topic Title: Authentication and Authorization. Your host for this session is Dan Lachance. [Video description ends]
In this video, we are going to be discussing the role that authentication and authorization play in allowing resource access in Linux.

First of all, authentication, what is this? Authentication really just means proof of identity, whether it’s signing in with a username and a password, because you might have a user account created on a local Linux host in /etc/passwd or you might authenticate with a centralized LDAP-based network account or a cloud-based centralized account. It doesn't have to be local on the Linux host to allow you to access Linux resources, but the accessing of resources is more on the authorization side where specific access is granted, such as the chmod Linux command being used to grant file permissions for users or groups. Of course, authorization could take on many other roles, such as being authorized to send confidential email, being authorized to use a VPN or authorized to access a web app.

The authentication part of this equation comes in many forms. We’ve talked about username and password. Despite the fact that that is two things, it’s still single-factor authentication because it’s one category of authentication, and that category is something you know. Authentication is also possible with something you have in your possession, something you have like a key fob, which is used as a security device for signing in, or it might be biometric authentication, something that you are; maybe using facial recognition or fingerprint or voice recognition solutions to authenticate users.

And of course, we can also use public key infrastructure or PKI certificates for authentication so that perhaps a user on their smartphone not only must have knowledge of the username and password to sign into a corporate VPN, but they must also have a trusted certificate on their client device.

So multi-factor authentication then means we are combining these various factors. The something you are type of stuff like fingerprints, facial recognition, something you know; maybe it’s a pin, an email address, a username, a password, something you have like a key fob or a smart card. It could also be gesture-based authentication, which really is reliant upon something that you do; movement in a certain way or drawing of a certain pattern to authenticate to a device.

In the cloud environment, such as with Microsoft Azure, authentication can occur centrally using Azure Active Directory or Azure AD. What this means is that even though we might have Linux-based virtual machines deployed in the Microsoft Azure cloud, we don't have to configure authentication within each Linux machine for every user account. So we can authenticate users and devices, whether they're Linux virtual machines or Android smartphones and what are called service principals and managed identities, both of which are used to authenticate software to Azure AD and also allows us to have something to give permissions to. For example, if a software running in a virtual machine needs access to cloud stored data, we could grant that virtual machine permissions through a managed identity instead of hard coding credentials within the code.

In our next screenshot here, we’ve got Azure AD multi-factor authentication or MFA user settings where in the rightmost column, the multi-factor authentication status is shown either as being disabled or enforced or enabled. [Video description begins] The screenshot contains a table with multiple rows and three columns; DISPLAY NAME, USER NAME and MULTI-FACTOR AUTH STATUS. [Video description ends] The difference between enforced and enabled is that enabled means you've turned on MFA, but the user hasn't yet signed in to complete that configuration. Enforced means the user has signed in at least once, configured what is required for MFA and is now fully using MFA when they sign in.

MFA is considered a good security practice because it's more difficult to crack an account using MFA than account that just uses single-factor authentication such as a username and a password. Not that MFA is not defeatable in some cases, but it's better.

Then we have this notion on a Linux host of Linux Pluggable Authentication Modules or PAM. This is one of those things that's used under the hood automatically, although you would rarely configure it. The purpose of PAM is that it separates authentication tasks from applications.

So if you're a programmer, whether you’re building a local Linux native-based app or a web app, you don’t have to build authentication into your app. It can happen externally such as in a centralized cloud directory like Azure AD or using standard Linux authentication mechanisms through PAM modules.

Now, there are many things that you will do as a Linux technician that will indirectly configure PAM, such as when you configure Secure Shell or SSH authentication, which makes some changes in /etc/pam.d which is a directory containing config files for a variety of services that can use pluggable authentication modules.

3. Video: Pluggable Authentication Modules (PAM) (it_oslsec_02_enus_03)

Upon completion of this video, you will be able to recognize how pluggable authentication module (PAM) is used for security in Linux.
recognize how pluggable authentication module (PAM) is used for security in Linux
[Video description begins] Topic Title: Pluggable Authentication Modules (PAM). Your host for this session is Dan Lachance. [Video description ends]
Let's take a few minutes to cover the concept of pluggable authentication modules in Linux. This is often shorthand referenced as PAM.

So what is pluggable authentication modules about? Well, it's a built-in subsystem built into all Linux distributions and the idea is that it separates the authentication tasks from whatever else commands or services are supposed to be coded to do, like serve up web pages or allow remote connections over SSH. So, you could say then that PAM sits between apps that need to use security services and the underlying security mechanisms themselves.

So think of things like account verification and authentication when users are trying to log in to a system performing things like password updates to a user account and other types of related security tasks such as auditing.

If you’re an experienced Linux technician, you might say: well, it's not something that I would configure very often, and this is true. Most of the time you will not be configuring PAM configurations directly. Of course, there are some times when you might. One example of which would be if you're installing and configuring some LDAP client software in order to use centralized LDAP user account authentication on an LDAP client instead of standard Linux authentication through /etc/passwd then there are some settings you would have to change. But in most instances you don’t configure PAM directly.

Pictured on the screen, we’ve got a screenshot of PAM library files. What’s been done here is the technician has typed in ls for listing of /lib/* and then /security so we’re looking at all of the security subdirectories under lib and what we're getting here is a listing of the files contained therein.

PAM modules normally have the so extension. Notice some of the file name examples such as pam_nologin.so to restrict logins on the host, there’s also a pam_ftp.so file. So depending on what software and services you have installed will control which PAM library files exist in your file system under lib.

In our next screenshot, the technician has issued the ls /etc/pam.d command. And so as a result we have a list of files within pam.d that we can configure. For example, the common-account file is one I would have to make a change to if I was working with some LDAP client software and I wanted to configure this machine to use LDAP authentication for LDAP user accounts as opposed to local authentication. But notice the other references to some of the other standard mechanisms used by PAM like cron, login, using the passwd command to reset user passwords, sudo and so on. [Video description begins] A new slide titled: Syntax: /etc/pam.d Files appears [Video description ends]

Now, within these configuration files, the syntax looks like this from left to right. First column deals with the module, such as whether it's related to an account type of item followed by the control flag. Now this will have a keyword that determines what happens with that module if authentication actually fails.

So you might have the keyword required set as the control flag in the second column. What that means is all of the modules that are listed on the line within this config file in /etc/pam.d they all must succeed, hence the word required.

The third column would be the name of the module. These are the files we saw in the security subdirectories under /lib such as the pam_nologin.so file which is used to prevent non-root users from signing in to the Linux host when we’ve got either a file called nologin in /file/run or a file called nologin in /etc.

And then finally the last column you'll find in a pam.d config file is any additional module arguments to control the module behavior, such as denying access to something specific like a file, or exactly what to do on an error condition. So for example, in a PAM config file you might in the leftmost column have account. So that's the module type. You might have the word required, which means that the modules listed on this line are needed and the only one listed here in the third column is pam_nologin.so. Notice that you don’t have to have any module arguments. It really depends on the nature of the module and how you want it to behave.

Here we have a screenshot of viewing binary command shared objects. The command that we happen to be looking at in this screenshot is the su command, which is in /bin so the command that’s been issued here then is sudo ldd /bin/su This really means show us all of these shared objects that are referenced in this case by the su command. Notice all of the various references to all of the PAM library files. [Video description begins] There are various references to PAM library files in the screenshot such as libpam.so.0 => /lib/x86_64-linux-gnu/libpam.so.0 and libpam_misc.so.0 => /lib/x86_64-linux-gnu/libpam_misc.so.0 [Video description ends]

su of course is what we use when we want to switch user accounts within an already existing Linux session. For instance, you might be signed in as your regular user account, but you might use su to switch to a different user account maybe if you're testing authentication. [Video description begins] A new slide titled: SSH Denied Users Using /etc/pam.d/sshd appears [Video description ends]

I’ll set a little example. If we were to take a look at how to deny SSH access to users using /etc/pam.d/sshd this is what we would add into that file. So I would add auth because this deals with authentication. It's not about session starting or ending or user accounts specifically, it's about authenticating.

We have required next, which means that all of the PAM modules listed here must work correctly. The one we're referring to here is a built in one in Linux called pam_listfile.so. This lets us configure any named file to be used with a PAM component.

We’re saying onerr=succeed which means that if we find a username in the listed file then we will block their login. Of course, the login for that user from their perspective fails, but it will have succeeded based on the configuration in this syntax.

Then I’ve got a space and a \ to continue to the next line. You can do that within configuration files to make them more readable.

The item here is a user. We’re talking about usernames that we’re going to be looking at within a file. And what we want to do is deny access and the file in question here, which is specified with file=/etc/ssh/deniedusers but really it can be any file. We get to decide and control that.

Now when it comes to these PAM configuration parameters like item and sense and file, this will vary from one PAM module to another. Some are similar, but you really need to refer to the documentation for that specific PAM module to know exactly what those mean and how they behave.

So therefore, if we were to take a look at a file in /etc/ssh called deniedusers in this example, it’s been catted so we can see that it contains one username mbishop. [Video description begins] A command is displayed on the screen: cblackwell@ubuntu2:/etc/pam.d$ cat/etc/ssh/deniedusers mbishop [Video description ends] Now that file is not there by default. You would have to create it and add user accounts, one per line for those users you want to block from having SSH remote access.

The result of which will look like this when mbishop tries to sign in. [Video description begins] The result displayed on the screen reads login as: mbishop mbishop@192.168.2.156's password: Access denied [Video description ends] Even with the correct password entered, they will be receiving an access denied message. That's when they try to log in remotely using SSH.

4. Video: Managing Linux User Accounts and Password Settings (it_oslsec_02_enus_04)

Learn how to create and manage Linux users with commands such as useradd, usermod, userdel, passwd, and who.
create and manage Linux users with commands such as useradd, usermod, userdel, passwd, and who
[Video description begins] Topic Title: Managing Linux User Accounts and Password Settings. Your host for this session is Dan Lachance. [Video description ends]
Let's take a few minutes to talk about how to work with user accounts in Linux. Now, certainly we'll be focusing most of our time doing that at the command line, but let's begin for a moment using Ubuntu desktop as our GUI example so that we can get a sense of what it might look and feel like if we're going to use a graphical environment to manage Linux user accounts.

So here with Ubuntu desktop, I'm going to start by opening up my menu from the bar on the left and I'll search for the word user. And here in our Settings we’ve got something here shown as Users, Add or remove users and change your password. Okay. I’ll click on that. [Video description begins] The Users window opens up with Settings pane and multiple categories on the left hand and Unlock option on the right hand. The username and three authentication and login options; Password, Automatic Login and Account Activity are visible in the center. [Video description ends]

So the first thing it shows me is who I am signed in as right now, which is a user by the name of Codey Blackwell. And if I were to click on Password, this is where I would have the option of changing my password, given that I know my current password, but I'll cancel out of that. [Video description begins] The Change Password dialog box appears with three fields to fill in; Current Password, New Password and Confirm New Password. [Video description ends] 

And if I click Account Activity, it conveniently just shows me the account activity for the account I’m signed in with now in terms of when the session started and when the session ended.

But at the top here, I can click the Unlock button if I want to work with additional user accounts. That’s similar to having to run sudo before you use Linux commands to manage user accounts; commands like useradd usermod userdel.

So if I were to click Unlock I’ll enter the password for this account Codey Blackwell. [Video description begins] There appears an Authentication Required prompt. It contains the username Codey Blackwell, a password box, and Cancel and Authenticate options. [Video description ends] Because what I’m really doing is taking advantage of my sudo elevated permission set. And once I've done that, I then have the ability to click Add User and to add a user account. [Video description begins] An Add User button shows up next to the Unlock button. [Video description ends] [Video description begins] The Add User box has two account type options; Standard and Administrator, two fields; Full Name and Username, and a Password section with two options; Allow User to set a password when they next login and Set a password now. [Video description ends]

So I'll enter in the full name. It'll automatically generate the short name. [Video description begins] He enters Lucas Brenner as the Full Name. The Username lucasbrenner gets generated automatically. [Video description ends] And this is just going to be a standard user, not an administrative type of user. I'll leave it on the default to allow the user to set a password when they next log in. And that's it. I’ll just click Add and it’s done.

So now notice that we’ve got two accounts shown at the top here in this GUI, Lucas Brenner and Codey Blackwell. Depending on the Linux distribution you're using and the desktop manager will really determine what this interface looks like but they're pretty easy to navigate through. But let's go to the command line. [Video description begins] The cblackwell@ubuntu2: ~ file is open in the Command Line Interface. [Video description ends]

Okay. So here at the command line, I’m going to start by running sudo useradd -m m meaning I want to create a home directory for the user. The user I will create will have a login name of jgold and if I use g I can determine the primary group that that user is a member of. Let’s say it’s called eastadmins. Notice if that group does not exist, you will get an error message so it will not create the group as you're creating the user. [Video description begins] He enters the command: sudo useradd -m jgold -g eastadmins On running the command the output generated is useradd: group 'eastadmins' does not exist [Video description ends] So for that I could run sudo groupadd eastadmins and if I use the up arrow key to go back to our useradd command, it succeeds. If we tail /etc/passwd we’ll have a reference here for user jgold. Notice it also assigned a unique user ID for the user account. It created a home directory because we specified -m under /home/jgold and notice the default shell is set to /bin/sh.

Now we haven't set a password for that account, so normally what we would do is run sudo passwd in this case for jgold and we’d specify and confirm the password for that account and then we’ll get a returned message about the password having been updated successfully.

So if we were to run sudo tail of /etc/shadow there’s jgold and in the second field, the delimiter is a full colon. We've got a hash of the user password. Now, of course, this is when you're working with a local Linux account. If you’re using with a cloud-based directory service that uses a centralized list of user accounts, naturally everything is completely different, just like it would be if let’s say, you were working with OpenLDAP to have a centralized network directory server containing user accounts and then installing the LDAP client on client devices to authenticate through that central directory. The method by which you would configure those user accounts would differ from what we are doing here and we’ll see how to configure LDAP a little bit later.

Now let me do a long listing of /scripts which is a sub directory that I have created and I created a file in there called script1.sh. [Video description begins] He runs the command ll /scripts Four lines of output are generated. Line one reads total 12 Line two reads drwxr-xr-x 2 root root 4096 Jul 10 15:50 ./ Line three reads drwxr-xr-x 20 root root 4096 Jul 10 15:50 ../ Line four reads -rwx------ 1 root root 50 Jul 10 15:50 script1.sh* [Video description ends] Notice the permissions here are read, write and execute for the owner which is being shown here as user root. [Video description begins] He highlights rwx in the third line of output [Video description ends] Now, of course, an important part of managing users in Linux is understanding ownership. So if I were to run sudo change owner chown is the command. I want to change to the owner jgold in our example and it’s going to be for the file in /scripts and the file is called script1.sh. Now if we do an ll of /scripts of course, the only user of this file is now showing as jgold which means now jgold has the read, write and execute permissions for that particular script.

Now let's also create a group here groupadd. sudo groupadd called linuxadmins. So what I want to do is add user jgold to that group as an additional group.

You might recall that if we do a tail of /etc/passwd there’s jgold but there’s no reference here specifically to the groups that that user is a member of. If we were to do an sudo tail /etc/shadow there's not a reference there either. So therefore, if we do an sudo tail of /etc/group notice what we have here is a list of group names. The second field is whether or not there's a group password, but the third one of course is the group ID.

For example, eastadmins has a group ID of 1002. If we were to tail once again /etc/passwd notice that jgold in the third column has 1002 the user ID, but the next occurrence of that happens to be the group ID. Let me show you what I mean. If I were to run sudo usermod for user let’s say jgold -g linuxadmins so I’m changing the primary group for jgold. Now remember the jgold listing in /etc/passwd had two occurrences of IDs 1002, but we've just changed the primary group.

So now if we once again tail /etc/passwd notice that the second occurrence of what used to be 1002 is now 1003. You might also recall if we do an sudo tail of /etc/group that linuxadmins has an ID of 1003. So that's the link then between groups and users.

Now of course, it's also important to know that we can switch to different users if we're already signed in to a Linux session of somebody else using the switch user command su by doing su - jgold. The - means perform a full login and run any scripts and what not for jgold prompted for that person’s password. And then I’m in as that user. We can verify this in a couple of ways. For example, if I type id it’s returning that I’m signed in currently as user jgold with an ID of 1002, primary group ID is linuxadmins, group ID of that group is 1003 and there might be some additional groups that this user is a member of as well. So that gives us an idea then of how we would do basic Linux user administration.

The last thing we’ll do here I’ll just exit out of that session is run sudo userdel jgold It’s that easy to remove a user account. So now if I do sudo tail of /etc/passwd notice the absence of user jgold.

5. Video: Creating and Managing Linux Groups (it_oslsec_02_enus_05)

During this video, discover how to create and manage Linux groups using commands such as groupadd, groupmod, groupdel, id.
create and manage Linux groups using commands such as groupadd, groupmod, groupdel, id
[Video description begins] Topic Title: Creating and Managing Linux Groups. Your host for this session is Dan Lachance. [Video description ends]
In this demo, we'll be taking a look at how to manage Linux groups from the command line. So the first thing we'll do here is just quickly take a look at the etc group file. [Video description begins] The cblackwell@ubuntu1: ~ file is open in the Command Line Interface. [Video description ends] So, sudo tail I’ll just do the tail end of it. /etc/group enter.

What we have here is a list of groups such as puppet. The second field will contain just a x. In the past that was something that was done rarely even then where you could have a group password. But following that, we then have the ID of the group. For example, notice we have a user here, cblackwell that’s actually a group name. Normally, in most Linux distributions these days, when you create a user, you also get a group with the same name. So we have a group called cblackwell with an ID of 1001.

If we were to run sudo cat /etc/passwd and grep that for cblackwell notice that the cblackwell user account has an ID of 1000, but in the next field we have 1001 which corresponds to the primary group that that user belongs to. However, of course, we can change all of that.

Let's start by creating a new group. I’m going to run the groupadd command, prefixed with sudo of course, and I’m going to call this group linuxadmins. So if we clear the screen and if we tail the etc group file, once again there’s linuxadmins with an ID of 1003. One of the things that we can do is we can either upon creation, assign a user to a group or change it at any point thereafter.

For example, let’s run sudo useradd -m to create a home directory -g and let’s assign them right away to the linuxadmins group. Now notice these are lowercase letters -m and -g. We’re going to create user jgold. I’ll press enter. So first things first, let’s do a cat of /etc/passwd and let’s grep this time for jgold. So jgold is shown here. The user has an ID of 1002 but we have 1003 shown here for the group identifier.

And if we tail /etc/group of course, 1003 is the ID of the linuxadmins group. But we could change user membership in a group after the fact as well. First of all, let’s add a new group. sudo groupadd eastadmins sudo usermod so instead of useradd usermod -g eastadmins and again that’ll be for jgold. So now if we take a look at /etc/passwd specifically the jgold line, notice now the group ID is showing as 1004. And if we tail /etc/group of course, as you might expect, that would be a reference to the group eastadmins.

But can't a user be a member of more than one group? Yes, there's the primary group, but then there are additional groups. For example, let’s add yet another group. sudo groupadd fulltimers Okay. What I can do is run usermod -a for append because what I want to do is not modify existing group memberships for the user, but simply add additional groups. But I'm going to use a G because I don't want to change the primary group that the user is a member of, just additional or supplementary groups. Then I can have a comma separated list of groups such as linuxadmins, fulltimers and then user jgold. [Video description begins] Two lines of output have generated. Line one reads usermod: Permission denied. Line two reads usermod: cannot lock /etc/passwd; try again later [Video description ends]

Of course we’ve got to prefix that with sudo so we have the correct elevated permissions to do that. [Video description begins] He runs the command sudo usermod -aG linuxadmins,fulltimers jgold He then runs the command clear [Video description ends]

However, if we were to do a cat of /etc/passwd again for jgold only their primary group ID shows up here 1004. Bear in mind here, while we’re looking at this, that jgold’s user ID is 1002. [Video description begins] He runs the command sudo cat /etc/passwd l grep jgold The output generated is jgold:x:1002:1004: :/home/jgold:/bin/sh [Video description ends] So if I tail /etc/group notice that in our group listing for linuxadmins and fulltimers in the fourth field, user jgold is shown as a member of both of those groups.

Now we can also modify some attributes of a group such as its name. sudo groupmod -n and the new name is going to be fulltimeemployees and the old name of course is fulltimers. And if we tail /etc/group of course now the group has been renamed to fulltimeemployees.

We can also remove members from a group if I do sudo gpasswd -d Let’s say we want to delete or remove jgold from the fulltimeemployees group. [Video description begins] He runs the command sudo gpasswd -d jgold fulltimeemployees The output generated is Removing user jgold from group fulltimeemployees [Video description ends] Okay. It says it did it, but we can only prove that if we tail /etc/group again. Indeed, it appears that jgold has been removed from the fulltimeemployees group.

The last thing we'll do here is just mention that we can remove groups in their entirety using sudo groupdel and then by specifying the name of the group. So if I want to delete the fulltimeemployees group, [Video description begins] He runs the command sudo groupdel fulltimeemployees [Video description ends] I can do that with groupdel. If we tail /etc/group the fulltimeemployees group indeed has been deleted.

6. Video: Viewing and Managing Linux User Configuration Files (it_oslsec_02_enus_06)

In this video, you will learn how to view and manage user configuration files controlling settings such as the default shell and environments variables.
view and manage user configuration files controlling settings such as the default shell and environments variables
[Video description begins] Topic Title; Viewing and Managing Linux User Configuration Files. Your host for this session is Dan Lachance. [Video description ends]
In this demo, we're going to take a look at how to work with Linux user configuration files. Now, you might be wondering, what does that mean exactly? Well, it is kind of a broad subject. So we're going to take a look at some user config files in terms of where local Linux user accounts exist, group definitions, we’ll take a look at some locations in the file system where you can actually populate subdirectories with files that will be copied to the home directory automatically of newly created users. So that's the type of thing that we're going to take a look at.

So let's start here first of all in Linux by running an sudo tail of /etc/passwd Of course that’s spelled passwd. This is the user account file for local Linux accounts. The reason I keep saying local Linux accounts is you can configure your Linux host to authenticate users where those user accounts exist elsewhere, like in a centralized LDAP server directory or even in a cloud-based directory service.

So with local Linux user accounts, the account information is stored in the password file. Now we've seen this a few times. We know that it starts with the username followed by an x in the second position, which really just means that the password hash for that account, if there is a password, is in the /etc/shadow file, which we’ll take a look at. We then have the ID of the user. [Video description begins] He highlights the following part of the last line from the output generated: jgold:x:1002:1004::/home/jgold:/bin/sh [Video description ends] In this case for user jgold the ID is 1002 and we also have the ID of the primary group that that user is a member of.

Now, what does primary group mean? Well, let's explore this just a little bit further. And this would be part of our talk about user configuration files. If we do an sudo tail of /etc/group that’s singular, notice that the group with an ID of 1004 is eastadmins. But also notice here in the group file, user jgold is a member of an additional group called linuxadmins which has an ID of 1003, but that’s not reflected up here in the password file for jgold’s account information. [Video description begins] He highlights two lines from the output; eastadmins:x:1004: and linuxadmins:x:1003 [Video description ends] [Video description begins] He highlights the following part of the output: jgold:x:1002:1004: [Video description ends] Only the primary group ID 1004 eastadmins is showing here.

So I keep saying primary group. What does that mean? Best explained through a quick demonstration. Let's do this. Let’s do an su - to do a full login to run all login scripts for a user and we’ll connect as jgold. [Video description begins] He runs the command su - jgold The output generated is Password: [Video description ends] So all we're doing is switching to that user account temporarily in a shell. So I’m prompted for the password for jgold. I’ll put it in. Okay. So we’re currently signed in now as jgold. [Video description begins] The prompt $ appears on the next line. He adds pwd next to it and runs the command. [Video description ends] If I type pwd print working directory, we are in /home/jgold.

Now if you're wondering why does the command prompt only look like a $, it’s just using a standard shell instead of a full bash shell. But we'll talk about that in just a moment. What I'd like to do is simply touch a new file. Let’s create a new file here in jgold’s home directory called file1.txt [Video description begins] He runs the command $ touch file1.txt [Video description ends] I’ll just do that with the touch command. If we do a long listing ll notice it doesn’t work here. Well, that’s more of a bash thing. [Video description begins] He runs the command $ ll and the output generated is -sh: 3: ll: not found [Video description ends] But if we do an ls -l that does work. [Video description begins] He runs the command $ ls -l and two lines of output are generated. Line 1 reads total 0 and line 2 reads -rw-r--r-- 1 jgold eastadmins 0 Jul 12 07:01 file1.txt [Video description ends]

Well, what I want to point out is simply this. When jgold is signed in and creates a file, jgold, of course, is set as the owning user and gets the user set of permissions and the primary group. Here's the primary group then for that user account is shown as the group owner of the file, which would get the group permissions. [Video description begins] He highlights rw in the output. [Video description ends] [Video description begins] He highlights eastadmins in the output. [Video description ends] In this case, just read. So whoever else is a member of eastadmins would also have read and everyone else of course would only have read as well. [Video description begins] He highlights r-- in the output. [Video description ends]

We know that that could be changed with the chmod command, but the point is that the primary group is important, although a user can be a member of multiple groups as we have seen. Let’s get out of this shell. Exit. We’re back into cblackwell. What I like to do once again is just go to sudo tail of /etc/passwd once again. Of course, when we sign in as jgold notice that we have /bin/sh. That’s why we had a weird shell.

What? Can we change that? Certainly. sudo nano /etc/passwd What I’d like to do is modify it such that user jgold has a standard bash prompt, kind of like cblackwell does up here. Notice cblackwell’s account in the last field here is defined as having a shell that will start called /bin/bash. Okay, well, in the bin directory, why don’t we refer to the bash binary here for jgold as well? [Video description begins] He replaces jgold:/bin/sh with jgold:/bin/bash which is a part of the output. [Video description ends]

We’ll save that out. And let’s do an su - of jgold and go back in again as that account. And of course now we have a standard command prompt. Remember how ll wouldn’t work with just a normal shell sh? If I type ll now, it works just fine because we’re in a bash shell. As we know, that’s one of the subtle differences that you will find when you’re using different types of shells to manage a Linux host.

If I do an sudo of tail for /etc/shadow of course we know that this is, so I’m going to exit out of that and go back to cblackwell where I’ll run sudo tail of /etc/shadow We know, of course, this works in conjunction with the /etc/passwd file. So here’s jgold’s account. And of course, we've got a hash of the password in the second field all the way down to the next colon.

Notice if I were to do an sudo passwd -l to lock out an account so it can't be logged in with. For jgold, it says the password was changed. Well, password was changed. Notice currently in our previous screen output for jgold here in the shadow file that the password starts with $y$j. Well, I should say the password hash starts with those characters. If we were to tail that file again, notice that the first character in jgold’s password hash is now showing as an exclamation mark. That means that that account cannot be logged into. It's been locked. You might do that, of course, for some kind of security reason, or if the person is on extended leave or on some kind of a sabbatical.

But what we can also do is turn it back on. We can run sudo passwd -u as you might guess, to unlock the account and then we specify the username jgold. Okay. It says password changed. Let’s tail /etc/shadow again and we’re back in business. There’s no longer an exclamation mark at the beginning of jgold’s password hash, which means that user can sign in. Let’s change directory to /etc/skel as in skeleton. If I do an ls there’s nothing in here. But what we can do is we can place files in here that we would like copied automatically to the home directory of newly created users. That can be incredibly convenient.

For example, let's create a sample file here. I’ll use the touch command to do that. I’ll have to prefix it with sudo of course, and we’re going to call it expensetemplate.xlt. If we do an ls there’s the expensetemplate.xlt. Let’s do another one. sudo touch vacationrequest.docx So this is just an example, but if we do an ls we have these two files in /etc/skel. [Video description begins] He runs the command /etc/skel$ ls The output generated reads expensetemplate.xlt vacationrequest.docx [Video description ends]

Let's create a new user account to see what happens. sudo useradd -m to create a home directory. And let’s say we’ll create user cjackson. Okay, it’s been done. If I do an ls of /home/cjackson of course I get a permission denied because I'm not logged in as root. If we do an sudo in front of that, notice the files that were copied to cjackson’s home account automatically; the expense template and the vacation request.

So having an understanding of how some of these user based config files interact together can be important in managing a Linux system.

7. Video: Using sudo to Gain Elevated Privileges (it_oslsec_02_enus_07)

In this video, find out how to configure sudo using commands such as visudo, sudo, su.
configure sudo using commands such as visudo, sudo, su
[Video description begins] Topic Title: Using sudo to Gain Elevated Privileges. Your host for this session is Dan Lachance. [Video description ends] [Video description begins] The cblackwell@Ubuntu1: ~ file is open in the Command Line Interface. [Video description ends]
In this demo, we’re going to be working with the configuration of sudo. Some people pronounce that sudo (su doh) but the purpose of sudo is to have regular users that can run commands as a privileged user. So commands a user normally doesn’t have permissions to run, it is possible to make that happen configuring sudo. So, consider the following example.

If I were to type in id it shows who I am currently logged in as. I am logged in as a user called cblackwell. So in other words, I am not logged in with the root superuser account and therefore there will be limitations on what I can do signed in as this account.

Consider, for instance, if I type fdisk -l I get a bunch of Permission denied when it tries to access devices in the /dev subdirectory structure. So it’s all Permission denied. However, if I clear the screen and run sudo as a prefix in front of it and then issue my command, that requires elevated permissions, so sudo fdisk -l this time it works spectacularly. [Video description begins] On running the command, multiple lines of output are generated including details about Disk, Disk Model, Units, Sector Size and I/O size. [Video description ends] And that’s because user cblackwell is set up to be allowed to run some or perhaps all privileged commands. It really depends on how sudo is configured, and that's precisely what we're going to examine.

But this is important because from a security perspective, we do not want to be signed in with the root super account all of the time. That is a bad security practice in case we might inadvertently cause problems on the system or delete important files. The other thing that's great about it is you don't want a bunch of Linux technicians all signing in as root because then there's no accountability. How do you know who did what exactly? It's better if admins have their own accounts and then use sudo to run privileged commands. Then we have a track record of who did what, when and where.

So let's take a look at the infrastructure or the supporting files, the configuration files for sudo. So I’m going to run sudo cat /etc/sudo.conf and we'll pipe that to more. I'll press enter. Okay. You'll notice that this file has a bunch of comments. Now, we're not really going to make any changes here and normally technicians probably wouldn't come in here to make changes. However, it is a config file related to sudo but that’s not really what we would do the bulk of any configuration work related to this.

Let’s do an sudo cat of /etc/sudoers The sudoers file will list some configurations for who is allowed to do what. What's very important here is understanding this syntax. [Video description begins] The command generates multiple lines of output. The presenter indicates the following two lines of the output: Line 1 reads # User privilege specification and line 2 reads root ALL=(ALL:ALL) ALL [Video description ends] Let's break this down for just a moment here. We’ve got a line in the sudoers file that begins with the word or the name root. Well, what does that mean? Well, that is the user to which we would like to grant privileges. It could be any user account name. It might also be a group name if you prefix it with %.

Then we have the word ALL. This first occurrence of the word ALL in this particular case means from which host should we allow this user to enter these commands? ALL of course, means all hosts. Now you can specify host names, you can specify IP addresses, you could specify a subnet, let’s say with a CIDR range notation.

After that we have = and in ( ) we have ALL:ALL. Well, the next ALL before the : to the left of it refers to the target run as user on the host that the commands will be run as a user to be able to run privileged commands as a specific other user. You can specify that other username here. After the colon, we have another ALL here still in the parentheses that would be for the target run as group. It's kind of like in Windows where you can run something as somebody else. That's what you're specifying here.

The last occurrence of the word ALL here in the sudoers file is which commands can be run by the user listed in the first column on the left. In this case, it's all commands, but you can have a comma separated list of commands. Now that's nice to say, but how does this behave? Let's do an example. I'm going to clear the screen.

When you want to make changes to sudoers, what you should be doing is running sudo visudo What that will do is it will let us edit the sudoers file. [Video description begins] He runs the command sudo visudo and the /etc/sudoers.tmp file gets opened as a result in GNU nano 7.2 tab. [Video description ends] Even notice at the top though here it says we’re modifying the sudoers.tmp because this is how it's done. One of the first comments at the top states This file MUST be edited with the ‘visudo’ command as root.

So there's some default settings being established here at the top of this file. And finally down below we have a User privilege specification section. There’s also an @includedir directive to include whatever content is within the /etc/sudoers.d file.

However, here I'm just going to add a line under root I want to do is make sure that user jgold can run fdisk. So I’m going to add jgold from any host. So ALL= and in ( ) I’ll put in ALL I don’t have to put in ALL:ALL I just want the run as target user on hosts to be any user that a binary that is being executed by jgold runs as then I can specify the path and name of the binary I want to allow access to for user jgold. So I’ll specify /usr/sbin/fdisk since that is where the binary actually lives. Let's press ctrl X to save this.

Now be careful. If there's a syntax error in here, then you might have problems trying to run commands with sudo that require elevated privileges. Okay. Save modified buffer? Yes. [Video description begins] On pressing control X, a prompt appears which reads Save modified buffer? and there are two options Yes and No. [Video description ends] And here we go.

So if I go back to sudo cat of /etc/sudoers notice it wrote to this file from the temporary file that we were just editing with visudo. So there’s user jgold’s listing to be able to run fdisk. By the way, if you don’t know where a binary is, you could issue the command whereis. [Video description begins] He is pointing to the following section of the output: jgold ALL=(ALL) /use/sbin/fdisk He then runs the command clear. [Video description ends]

For example, whereis fdisk and here it's coming back and telling me where the binary is and even where the compressed man page or help pages for that command. [Video description begins] He highlights /usr/sbin/fdisk in the output generated. [Video description ends] [Video description begins] He highlights /usr/share/man/man8/fdisk.8.gz in the output generated. [Video description ends]

Now, we need to test this out. What we’re going to do is we’re going to switch to user jgold and try to run fdisk with and without sudo. su -jgold to switch to that account. [Video description begins] He runs the command su - jgold and the output generated reads Password: and the prompt changes from cblackwell@Ubuntu1:~$ to jgold@Ubuntu1:~$ He then runs the command clear. [Video description ends] Okay. We are now jgold. If we simply run fdisk -l we get the Permission denied stuff that we saw previously.

If we run sudo fdisk -l it’s normal the first time you do this for it to ask for that user’s password. So I’ll put in jgold’s password. And sure enough, the command is working. So if you need to specify specific commands binaries that should be runnable by regular users that otherwise can't run them, you can go ahead and modify the sudoers file with visudo. [Video description begins] On running the command, multiple lines of output are generated including details about Disk, Disk Model, Units, Sector Size and I/O size. [Video description ends]

8. Video: Linux Remote Management (it_oslsec_02_enus_08)

After completing this video, you will be able to list standard remote management tools used in Linux environments.
list standard remote management tools used in Linux environments
[Video description begins] Topic Title: Linux Remote Management. Your host for this session is Dan Lachance. [Video description ends]
As a Linux technician, knowing the different ways to remotely manage Linux hosts is paramount. So we’re going to go ahead and talk about command line as well as GUI tools. Although the focus certainly will be on command line.

The other thing to think about is network exposure. If we've got Linux virtual machines, let's say, running in the public cloud, do we want each of those to have a public IP address, which means they’re visible and thus reachable directly over the Internet? Usually the answer is no. We don’t want them directly exposed to the Internet unless there’s a specific reason. So instead we might choose to use a jump box, which is essentially a server that has a private internal network interface and a public one so it’s reachable over the Internet. And when you authenticate to the jump box, you then use it as a sort of launching pad to then remotely manage internal hosts using their private IPs.

But there are a lot of other considerations for Linux remote management, one of which is should root be able to connect? Do we want the root super account to be able to SSH directly into a host? If not, users would then be able to SSH into the host, presumably unless they're denied in some way. But technically, once they’re SSHed in they could just use sudo to run elevated privileges. Or if they really wanted to, they could use the su command to switch over to root.

From which locations should we allow remote management over SSH? For example, are we going to use a jump box or have a VPN connection that is required to be established prior to remote management? That would mean that the Linux hosts would only be reachable with a private IP and thus would not be exposed on the public Internet.

Will we be remotely managing on-premises or cloud-based Linux VMs? The only difference really is how you might make a connection in the first place to gain access to that relative network. And of course, which tools will we use for remote management?

Let's take just a minute and talk about some common Linux remote management tools, both old ones that are really deprecated and insecure and probably shouldn't be used as well as new ones. Of course, using Secure Shell or SSH is preferred and has become the norm for quite a long time now. If you're at the right software installed, you can even enable X forwarding.

Now we're talking here about the X Windows framework, which means that, for example, you could be sitting at a Windows host SSHed into a Linux host where there are GUI applications installed and by issuing the command through the SSH remote connection where X forwarding is enabled, actual GUI interface for that app would show up on your local Windows machine. No, really it’s running on the Linux host. Quite interesting. You might also use SSH to take advantage of local and reverse tunneling. We'll talk about those in more detail in just a few moments.

The VNC GUI remote management tool is often used to make a remote management connection, such as to Linux hosts that have a GUI configured.

There are other command line tools like SCP or secure copy, which is used to copy files between hosts over SSH or secure FTP, which is yet another secured way to transfer files between hosts. Then you've got the older, less secure mechanisms like telnet and rlogin which send all of the credentials in clear text. And really those ones shouldn't be used. There’s no reason to use those when you have things like SCP and SSH.

And as you might imagine, there is quite a wide array of third-party, GUI and command line tools beyond what we've mentioned that you might choose to use for Linux remote management.

When it comes to secure shell or SSH, public key authentication is an option. [Video description begins] A new slide titled Secure Shell (SSH) Public Key Authentication appears. It contains a diagram with a computer symbol labelled SSH private key on the left side, a left to right arrow labelled SSH remote management over TCP port 22 in the center and a remote symbol labelled SSH public key on the right side. [Video description ends] If you're not using this, you're probably just using username and password authentication.

But with SSH public key authentication, every Linux technician would have to have a unique public and private key pair issued to them where their SSH private key would be stored safely on their administrative workstation and should be at least password protected and backed up. When they make the SSH remote management connection over TCP port 22 to the SSH server, as long as the SSH server has the related public key for that user in a hidden SSH directory in the user home directory on the server, then the user will be able to successfully authenticate.

Now when the user opens that connection initially and authenticates, they might be prompted for a passphrase which wouldn't be for their user account on the server, but rather a passphrase that's used to protect their local private key file.

So how were these keys generated? There are so many different ways, but in this screenshot notice the technician has issued the ssh-keygen command with -t for type and then rsa so generating an RSA public and private key pair. The second highlighted item in our screenshot is the private key, which by default is called id_rsa so that needs to be stored on the technician station and should never be shared with anybody.

And then we’ve got id_rsa.pub which of course stands for public. That's the public key. And there’s no security risk with sharing that with everybody. That needs to be in the user home account, in the hidden SSH directory on the server. [Video description begins] A new slide titled Microsoft Azure Linux VM Authentication Options appears. It contains a screenshot of the Reset password section in the Ubuntu1 Virtual Machine window. There are several Automation and Help options on the left side. On the right side, there are three Mode options; Reset password, Reset SSH public key and Reset configuration only. There is a Username field and an SSH public key field below. [Video description ends]

In our next screenshot, we have an example of the properties of a virtual machine. A Linux virtual machine running in the Microsoft Azure cloud. In the left hand navigator, what’s been selected is Reset password. You also get these same types of options when you initially deploy a Linux virtual machine. But notice on the right that we can configure this for password authentication so standard username and password. If you forget the password for a cloud-based Linux VM, you can reset it here. The username is specified upon creation, but notice we also can select a mode of Reset SSH public key where we could specify the username to which the public key is tied and then paste in the SSH public key. As we know, the admins station is where the related private key would be stored.

9. Video: Secure Shell (SSH) Port Forwarding and Tunneling (it_oslsec_02_enus_09)

Upon completion of this video, you will be able to outline how local and remote Secure Shell (SSH) port forwarding works.
outline how local and remote Secure Shell (SSH) port forwarding works
[Video description begins] Topic title: Secure Shell (SSH) Port Forwarding and Tunneling. Your host for this session is Dan Lachance. [Video description ends] SSH tunneling is common. Often it’s referred to as port forwarding. What happens with SSH tunneling is you have the option of configuring local port forwarding. What this means is that you've got the SSH client configured with the listening port locally on the client where you issued the command and traffic is sent through an SSH tunnel when it's destined for that port to an SSH server elsewhere and that could be used as a great jump box solution.
So we're talking about tunneling network connections through a secured network tunnel, kind of like a VPN, except it's not a VPN, it's just an SSH tunnel. VPNs are a little bit more general in that they’ll allow any type of traffic. This is specifically an SSH tunnel.

We also have the option of remote port forwarding. What's this? Well, as you might guess, it's the opposite of local port forwarding, which means that what we would be doing, for example, from a client is specifying a remote listening port on an SSH server And when traffic arrives on that remote server at that port number, it would be sent through the SSH secured tunnel to the client. So that way you might use it to grant SSH clients access to an internal host that might not be publicly visible. Although the SSH server that is listening with that remote port number would need to be publicly visible. We'll take a look at these in diagrams shortly.

Then there's the notion of something called dynamic port forwarding that you might choose to configure with your SSH tunnel. This is very, very similar to local port forwarding. The only difference really is that it's designed to be used by certain types of apps that require a SOCKS proxy connection.

Okay, let's talk about SSH local port forwarding or tunneling, whichever term you'd like to use to refer to this. [Video description begins] The slide contains a diagram with 3 symbols. The computer symbol on the left is labelled SSH client, there is a left to right arrow labelled SSH session over TCP port 22 and a remote symbol on the right labelled SSH server running Apache2 web server on TCP port 80. [Video description ends] Here we've got an SSH client shown on the left of the diagram and the command that’s been issued here is ssh -L which means local port forwarding. We have 80: and then 127.0.0.1:80 that means we are capturing traffic going to port 80. And then we’re referring to cblackwell@sshserver. So that means on the client, if you were to type in http://127.0.0.1:80 normally that would connect to a web server stack running on your local SSH client.

But what we're doing here with this local port forwarding, think of that term local port that would be local port 80 forwarding to somewhere else. We would be forwarding it instead to the SSH server where the Apache2 web server would be running, let's say on TCP port number 80. Now that can be handy if, for example, a firewall doesn't allow connections to port 80 on the SSH server, but it does allow port 22 connections for SSH. The port 80 traffic is really just going through the SSH tunnel. So this is a great way that you can take a protocol that might normally not be secure and make it secure because SSH provides a secured encrypted tunnel. And also of course to make a remote service like the Apache web server running on the remote server here appear to be local to the machine, in this case to the SSH client. [Video description begins] A new slide titled SSH Remote/Reverse Port Forwarding/Tunneling appears. [Video description ends]

The opposite is SSH remote or reverse port forwarding or tunneling. So there are a lot of different ways that this is referred to when it comes to literature. Let's take a look at what we've got going on here.

On the left, we've got an SSH client and let's say it's a developer website that’s running on the SSH client on TCP port 2000. Let’s say, in this example, however, this SSH client machine is just a client desktop on a network, maybe a laptop. [Video description begins] There is a diagram on the screen. On the left side, there is a computer symbol labelled SSH client, then a left to right arrow labelled SSH session over TCP port 22 which points to a remote symbol. There is a right to left arrow and then a computer symbol labelled Internet users with web browsers connect to http://sshserver:80 [Video description ends] It's not reachable from the Internet, maybe because it doesn't have a public IP. There's a firewall blocking port 2000 traffic. It’s using NAT whatever the case is.

But notice on the right we do have an SSH server that is reachable from the Internet. Now if the goal here is to have Internet users, which is reflected here in the diagram on the rightmost part of the picture, we want those Internet users to be able to connect to our developer website. [Video description begins] The presenter is indicating the remote symbol in the diagram. [Video description ends] But we don't have a public visible IP, but we can authenticate to an SSH server that does. So what we would do on the SSH client shown here in the bottom left is from the command line, we would run ssh -R because this is remote port forwarding. What we're defining here is a remote listening port number and what we want to redirect it to.

So what we’re going to do is specify 80: that means on the remote SSH server, any traffic that comes to port 80, we want to redirect to our local 127.0.0.1 IP on port 2000. And again, think of the terminology - remote port forwarding. The remote port here is 80, which is going to be forwarded through the SSH tunnel to the client on port 2000. Of course, in your SSH command you still have to authenticate to the SSH server in this case as cblackwell. So in the bottom center of our diagram, it says client connections for TCP port 80 on the SSH server are forwarded to the SSH client TCP port 2000. Ultimately, that means internet users with web browsers can connect to http://sshserver:80 and they think they’re connecting to the SSH server. Really the website they’re pulling up is the one running on the developer's SSH client station. Pretty neat.

Now in order to make an SSH server that's publicly visible to support this, there's a little bit of an SSH configuration that you have to change in one of the SSH config files. You would have to allow a setting called gateway ports. So that sums up some of the things to think about when it comes to how you might remotely manage Linux hosts.

10. Video: Configuring SSH Remote Management (it_oslsec_02_enus_10)

Discover how to enable SSH remote management using commands such as ssh-keygen and ssh-copy-id, and configure SSH tunnelling.
enable SSH remote management using commands such as ssh-keygen and ssh-copy-id, and configure SSH tunnelling
[Video description begins] Topic Title: Configuring SSH Remote Management. Your host for this session is Dan Lachance, [Video description ends] [Video description begins] The cblackwell@Ubuntu2: ~ file is open in the command line interface. [Video description ends]
In this demo I will be configuring SSH remote management. We know that SSH or secure shell is a secured encrypted way to remotely connect to another Linux host to remotely manage it. And this would be in place of using less secure protocols that send everything in plain text like telnet or rlogin.

So what we're going to do then is we're going to start on the client machine. What that means is this would be the technicians Linux station from which they will SSH into the server remotely over the network located elsewhere. So on this server, I'm going to switch to the user account that I want to enable SSH remote management, basically SSH public key authentication form. So I’m going to run su - jgold I have a user account on this host called jgold, so I'm going to switch to their account and I'll clear the screen pwd print working directory. We’re in the jgold home directory on this host Ubuntu2 which we’re calling the client. Now over here on Ubuntu1 a different host and this is going to be the target that will be SSHed into from the client.

If I do an ls of /home notice that we also have a jgold sub directory. [Video description begins] He switches to the cblackwell@Ubuntu1:~$ host. [Video description ends] [Video description begins] The output generated reads cblackwell cjackson jgold mbishop [Video description ends] So we have a jgold user account on both machines. In a larger enterprise you might only have one occurrence, one instance of the jgold user account in a central directory service like LDAP, for example. But in this case the account exists on both hosts as a local Linux account.

So back here on Ubuntu2 which we call the client station, I’m going to run the ssh-keygen command. Now, this command will generate a unique public and private RSA key pair and we're going to be using this for public key authentication over SSH. Now instead of just having the knowledge of a username and a password to make a remote SSH connection, this will add another factor for authentication to make it harder for malicious users to crack into because they'll have to possess the private key in addition to having knowledge of a username.

So I'm being asked to enter the file in which to save the key. Now this is the private key file. Notice what it wants to do. It wants to put it in the user's home directory in a hidden directory called .ssh. Hidden directories are prefixed with the dot and within there it wants to call the file id_rsa. I’m okay with that. So it’s created that hidden ssh directory and it wants me to enter a passphrase to protect the private key file, the id_rsa file. So I'll go ahead and enter a passphrase and I'll enter it again. Okay. It also has a reference here to the fact that my related public key has been saved in that hidden ssh directory. Its file name is id_rsa.pub for public key. Okay. And that is correct.

If I do an ls here of .ssh Those are the two files that are there, the private key and the public key. [Video description begins] The output generated reads it_rsa id_rsa.pub [Video description ends] The private key must reside here on my client admin station in my home directory in the hidden .ssh directory. But the public key which is currently on this machine, we need to get that to the server that we want to SSH into. And on the server it needs to be in my home directory in the .ssh hidden directory specifically. It needs to be placed in a file on the server in the hidden .ssh directory for my user account called authorizedkeys.

Now I could manually copy the file over using any mechanism I choose, but there is an SSH command that's designed to copy public keys from the local host to the server. So to do that I’ll just run ssh-copy-id Now I have to specify the credentials for the user account. So jgold is the username @ and here on Ubuntu1 I’ll run ip a to get the IP address of that server 10.0.0.4. So @10.0.0.4 back here on the Ubuntu2 client machine and I’ll press enter.

Now as usual, the first time you SSH into a server, it asks if you trust its fingerprint. Are you sure you want to continue connecting? I'll type in yes and press enter. So of course it’s asking me to provide jgold’s password. So I’ll put in the password and that’s on the target host. Okay. It says Number of key(s) added: 1 and it says, Now try logging into the machine, with: “ssh ‘jgold@10.0.0.4’ ” because here on the server, if we do an ls of /home/jgold/.ssh Okay, let’s give that a go. ssh jgold I’m currently signed in as that account locally, but I want to connect remotely with that account @10.0.0.4 Enter. What it's asking for is a passphrase for my local private key. It is not asking for the password for jgold on the target server. So I'll enter that passphrase and then that's it. I am in notice my command prompt has changed to reflect that I am now connected to server Ubuntu1.

If I do pwd print working directory, we’re in the jgold home directory. If I do an ls -a there’s the .ssh directory. Let's change directory into it to take a peek. Clear the screen. ls there’s the authorized keys file. We need to take a look at that cat authorized_keys Enter. So this is where we have our SSH public key as we know that needs to reside on the target server you’re SSHing into where the private key is stored on your administrative client station.

11. Video: Installing and Configuring an LDAP Server (it_oslsec_02_enus_11)

Find out how to enable an LDAP authentication server.
enable an LDAP authentication server
[Video description begins] Topic title: Installing and Configuring an LDAP Server. Your host for this session is Dan Lachance. [Video description ends]
In this demonstration, I will be installing and configuring an LDAP server. LDAP stands for Lightweight Directory Access Protocol. It's normally accessible over the network through Port 389 on TCP or if it's a secured connection or report 636. But those ports really could be anything. Those are just the standard ports. LDAP serves as a centralized network directory. It's a database containing network configuration objects such as user accounts. Therefore, we could set up an LDAP server with user accounts to allow users from hosts over the network where the LDAP client is installed to sign in with their centralized LDAP client account.

So the first thing we’re going to do on this host, which is named Ubuntu1 is we're going to be setting it up as an LDAP server, but we really want to make sure we set the host name on it correctly first. So I’m going to run sudo hostnamectl set -hostname We’re going to call this ubuntu1 and I’ll press enter. Then I’m going to run sudo nano the nano text editor /etc/hosts and we’re going to make sure we have an entry here for this host’s IP address 10.0.0.4 and we’re going to add ubuntu1. I could have added just ubuntu1 on the previous line where we already have the server's IP, but a separate line is fine as well. So I'll go ahead and save that to that file and the next thing I'll do is run sudo apt install and the LDAP server components I will install will include slapd ldap-utils. So I'm installing two packages at once with one command. It asks down at the bottom, Do you want to continue? Because it's going to take up some disk space. Yes, I do want to continue. I'll type in the letter Y and I'll press enter.

So I'm prompted to enter the administrator password for the admin account in my LDAP directory. So I'll go ahead and enter an administrator password and I'll press enter. Then I need to confirm it and I'll press enter on that. Okay. So it's installing those LDAP components for me now.

To verify that that installation was successful, I’ll run sudo slapcat and I’ll press enter. What this will do is return some basic LDAP information here about my installation and if it returns back this information, including the distinguished name the dn which of course we've not yet configured, if it returns back the creator’s name being common name or cn=admin,dc or domain component =nodomain, we are good.

And if I enter the sudo service slapd status command, it's showing that the LDAP server is active and running. But really we've not yet configured it with anything specific to our installation. For that, we’re going to run sudo dpkg-reconfigure slapd It says If you enable this option, no initial configuration or database will be created for you. Omit OpenLDAP server configuration? No, we do not want to omit it. Okay.

So now it asks us for our DNS domain name, which is used to construct the base distinguished name of the LDAP directory. So let’s set that to quick24x7.local and I’ll press enter. The Organization name, well let’s put in quick24x7 enter. The Administrator password, we’re going to enter one and we’ll confirm it. It says, Do you want the database to be removed when slapd is purged? I’ll accept the default of <No> and press enter. It states that there’s an old database, the default one as part of the install. Move the old database? <Yes> I’ll press enter. So it's creating my LDAP directory.

If I run sudo slapcat press enter notice now instead of the default no domain stuff we had initially, our LDAP directory is now showing that the distinguished name here up at the top is dc domain component =quick24x7,dc=local.

The next thing we can do is run sudo nano and we can take a look at the /etc/ldap/ldap.conf file. So here we've got a bunch of LDAP default settings like the size and time limit settings for returning results when LDAP queries are received. What I want to do here is uncomment the baseline here and make sure that this reflects what I've configured where the domain component is quick24x7,dc=local in my case, and I’ll uncomment the URI line and just replace the DNS name with my server name, which is just ubuntu1 that’s resolvable to the IP address. Notice here it's going to be listening for those types of queries on port 666. That can be changed to whatever it is that you want it to be. The normal listening port here, unless you're using an SSL type of connection is port 389. I'm going to put that in there and that's all I'm going to do here. I'm going to close and save that file and I’m going to run sudo ldapsearch -x just to do a quick simple search to at least make sure the server is responding to these types of requests.

The next thing I'll do is run sudo nano to open up a file I’ve already created called ou.ldif. ldif files can be applied to an LDAP directory to add entries like OUs or user accounts or to modify them or to remove them. The default is to add unless you specify the change type parameter.

So here in this file I’ve got dn: and then I’ve got the distinguished name, the dn of a new OU I want to add to my LDAP directory ou=hq, and then I’ve got dc for domain component =quick24x7,dc=local Next line I have objectClass one word where class is spelled with a C: top top is in lowercase. Next line objectClass: organizationalunit all lowercase and then the next line ou: hq all lowercase. I want to create the hq for headquarters, organizational unit or ou and I could add multiple entries here, each separated with a blank line, but I'm just going to create the one.

So I’ll get out of here and I will run sudo ldapadd -x -D Then I have to authenticate to my directory. So cn for common name=admin,dc=quick24x7,dc=local -W -f and I’ll point to my ldif file ou.ldif. When we press enter, we'll be prompted to authenticate to our LDAP directory. So I'll enter the LDAP password for the admin account. Okay. And it will have added the new entry for the hq ou. We can verify this with sudo slapcat What we've got now is a new entry for our organizational unit that wasn't there previously. In the same way, if we were just to do an sudo ldapsearch -x it’s going to be returning the hq organizational unit. We'll take a look at setting up an LDAP client in another demo.

12. Video: Configuring LDAP Client Authentication (it_oslsec_02_enus_12)

Learn how to configure client LDAP authentication.
configure client LDAP authentication
[Video description begins] Topic title: Configuring LDAP Client Authentication. Your host for this session is Dan Lachance. [Video description ends]
In this demo I will be installing and configuring an LDAP client. LDAP of course, is the Lightweight Directory Access Protocol. We've already set up an LDAP server, a centralized network database, essentially where we can have user accounts, and that means that we can have user devices, Linux hosts authenticate with a central LDAP user account instead of having to authenticate with a local Linux account. If you think about it, if I’ve got a user such as mbishop and I want that user to be able to sign in to many machines over the network, I only have to create that account once centrally in LDAP as long as those Linux hosts are configured correctly as LDAP clients. So that's what we're going to focus on here, how to get an LDAP client up and running.

Now, I happen to be doing this on the same host that is the LDAP server, but it doesn't make a difference as long as traffic over the network is allowed, for example to port 389, the default listening port for LDAP. We also have to make sure that we can ping the LDAP server by name or connect to it by IP address and that it will respond correctly. [Video description begins] The cblackwell@ubuntu1: ~ file is open in the command line interface. The presenter runs the command ping ubuntu1 The output generated is PING ubuntu1 (10.0.0.4) 56(84) bytes of data. This is followed by multiple lines of output. [Video description ends]

Now, if you don’t get a response from PING it might be that the firewall is blocking ICMP, but again, port 389 traffic is the standard port used by LDAP. On the LDAP server, if we were to do an sudo service slapd status we would see whether or not the OpenLDAP Server Daemon is up and running. [Video description begins] He runs the command clear. [Video description ends] Here it is. It's active and running.

If we were to run sudo slapcat we'd be able to see the objects that exist within the LDAP directory. So my directory here is quick24x7, local, those are the domain components or dc but I’ve also got an hq for headquarters, organizational unit shown here as an ou and within hq I’ve got a couple of users like mlin that’s in hq. I’ve also got an account here such as ldapuser1. An ldapuser1 for instance, notice also has a number of Linux specific attributes here such as the loginShell, the user ID number, the group ID number for the primary group of this user, the home directory location for this user. [Video description begins] He highlights 4 lines of the output. Line 1 reads loginShell: /bin/bash Line 2 reads uidNumber: 2000 Line 3 reads gidNumber: 2000 and line 4 reads homeDirectory: /home/ldapuser1 [Video description ends]

I’ve also got a group down here called sales group which has a group ID number of 2000, which corresponds with the primary group number up above for ldapuser1. [Video description begins] He highlights two lines of output. Line 1 reads cn: salesgroup and line 2 reads gidNumber: 2000 [Video description ends] So this already exists here on the server. If I were to do an sudo nano of the user.ldif file, this is a file I created and called as such, this is the definition file for the creation of my users and groups [Video description begins] On running the command, the user.ldif file opens in the GNU nano 7.2 window. [Video description ends] and that file is applied to my LDAP directory to add those objects to add those users and groups using the ldapadd command with the -x -D I specify the admin for my LDAP directory and then -W -f and then the name of the file user.ldif. That’s already been done to add those to my directory.

What I've also done is run a sudo ldappasswd where passwd is spelled p a s s w d with a -H and then I’ve specified the LDAP URL for my server which is ubuntu1 -x -D. Then I’ve got the credentials for the admin -W -S and then I’ve got the user ID whose password I want to set. Here I’ve set a password for ldapuser1 so that’s how that stuff comes about in an LDAP directory.

So I need to install some software here. sudo apt install libnss-ldapd libpam-ldapd ldap-utils -y for yes and enter. Okay. At this point I’m prompted for the LDAP server URI [Video description begins] The Configuring nslcd window appears on the screen. [Video description ends] so I’ll just specify ubuntu1 and enter and the LDAP server search base, I can specify as dc=quick24x7,dc=local. I could also put in of course, if I want to have the search base set further down in the hierarchy I could put ou=hq, and then have my domain components listed after. I’ll press enter. I want to make sure I configure the passwd command, group and shadow. These are services that should use LDAP.

I’ll press enter and then using a text editor, if you go down to /etc/pam.d/common-session you can add a new line as I have here at the bottom that says session optional then we’re referring to the pam_mkhomedir.so file. We’re setting the skeleton variable to /etc/skel so any files in there will be copied to the new user home directory. And we're setting a umask to set the default file permissions to be equal to 077.

And then we have to restart the two client daemons for LDAP nscd and nslcd. You can do that using systemctl or the service keyword. It really doesn't matter. Or if you want it to, you could reboot the system. But either way, we are ready to test it.

If I were to do an sudo cat /etc/passwd and let’s say we grep that for ldapuser1. There's no local LDAP user account. Yet if I run su - to switch user, of course I could just reboot the system or log out and completely log in as an LDAP user, you don’t have to just do it through su - ldapuser1 It knows about it because it's asking for the password. But there’s no local ldapuser1 account on this Linux host. That is the entire point with LDAP. It's stored on the LDAP server centrally. I'll just go ahead and enter the password for that account and I'm in. It’s created a directory under /home for my LDAP user and of course I am currently signed in as my LDAP user. So that's how you go about configuring an LDAP client on a Linux host.

13. Video: Course Summary (it_oslsec_02_enus_13)

In this video, we will summarize the key concepts covered in this course.
summarize the key concepts covered in this course
[Video description begins] Topic Title: Course Summary. Your host for this session is Dan Lachance. [Video description ends]
So, in this course, we’ve examined how to secure a Linux system in terms of authentication and remote management. We did this by exploring authentication and authorization and using PAM for security. We managed Linux user accounts and password settings, Linux groups and user configuration.

Following that, we worked with using sudo commands, remote management and configuring SSH remote management. And lastly, we installed and configured an LDAP server and an LDAP client. [Video description begins] A slide titled: Coming Up Next appears. [Video description ends]

In our next course, we'll move on to select, configure and manage firewall and IDS solutions, as well as how to monitor security incidents.

© 2023 Skillsoft Ireland Limited - All rights reserved.